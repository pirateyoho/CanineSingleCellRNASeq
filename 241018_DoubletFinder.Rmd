---
title: "Doublet Finder"
author: "Eileen Owens"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = TRUE,
                      cache = TRUE,
                      warning = FALSE,
                      keep_md = TRUE)
```

# Introduction
The purpose of this script is to identify doublets in single-cell RNA-seq data. Doublets are a type of artifact that arises when two or more cells are captured by a single reaction volume and sequenced as a single cell. This can complicate interpretation of downstream analyses to determine cell identity and heterogeneity.

This script has been adapted from the DoubletFinder documentation (https://github.com/chris-mcginnis-ucsf/DoubletFinder) and publicly available tutorials (https://rpubs.com/kenneditodd/doublet_finder_example, https://biostatsquid.com/doubletfinder-tutorial/).

# Data and package loading
## Load necessary software packages
```{r software-load, results="hide", message=FALSE}
library(Seurat)
library(tidyverse)
library(DoubletFinder) # remotes::install_github('chris-mcginnis-ucsf/DoubletFinder')
```

## Set working directory
```{r setwd}
setwd("C:/Users/edlarsen/Documents/240828_scRNAseq")
```

## Load single-cell RNA-seq count data
Input: A Seurat object that has already been filtered to remove low quality cells.
```{r data-import}
filtered_ln <- readRDS(file = "C:/Users/edlarsen/Documents/240828_scRNAseq/seurat_merged_LN_filtered.RData")
filtered_thym <- readRDS(file = "C:/Users/edlarsen/Documents/240828_scRNAseq/seurat_merged_THYM_filtered.RData")
```

DoubletFinder should not be applied to aggregated scRNA-seq representing multiple distinct samples (e.g., multiple 10X lanes), so the Seurat object will be split based on the sample ID.

```{r sample-split}
# returns a list of n Suerat objects, 1 per sample.
ln_split <- SplitObject(filtered_ln, split.by = "orig.ident")
thym_split <- SplitObject(filtered_thym, split.by = "orig.ident")
```


# DoubletFinder function

```{r}
# Functions ===================================================================
#----------------------------------------------------------#
# run_doubletfinder_custom
#----------------------------------------------------------#
# run_doubletfinder_custom runs Doublet_Finder() and returns a dataframe with the cell IDs and a column with either 'Singlet' or 'Doublet'
run_doubletfinder_custom <- function(seu_sample_subset, multiplet_rate = NULL){
  # for debug
  #seu_sample_subset <- samp_split[[1]]
  # Print sample number
  print(paste0("Sample ", unique(seu_sample_subset[['orig.ident']]), '...........')) 
  
  # DoubletFinder needs the multiplet rate of your sample (i.e., the expected  proportion of doublets). If you don't know the multiplet rate for your experiment, 10X published a list of expected multiplet rates for different loaded and recovered cells. If a multiplet rate is not provided, this function will automatically determine how many doublets to expect for a given number of cells in a sample.
  
  if(is.null(multiplet_rate)){
    print('multiplet_rate not provided....... estimating multiplet rate from cells in dataset')
    
    # 10X multiplet rates table
    #https://rpubs.com/kenneditodd/doublet_finder_example
    multiplet_rates_10x <- data.frame('Multiplet_rate'= c(0.004, 0.008, 0.0160, 0.023, 0.031, 0.039, 0.046, 0.054, 0.061, 0.069, 0.076),
                                      'Loaded_cells' = c(800, 1600, 3200, 4800, 6400, 8000, 9600, 11200, 12800, 14400, 16000),
                                      'Recovered_cells' = c(500, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000))
    
    print(multiplet_rates_10x)
    
    multiplet_rate <- multiplet_rates_10x %>% dplyr::filter(Recovered_cells < nrow(seu_sample_subset@meta.data)) %>% 
      dplyr::slice(which.max(Recovered_cells)) %>% # select the min threshold depending on your number of samples
      dplyr::select(Multiplet_rate) %>% as.numeric(as.character()) # get the expected multiplet rate for that number of recovered cells
    
    print(paste('Setting multiplet rate to', multiplet_rate))
  }
  
  # Pre-process seurat object with standard seurat workflow --- 
  sample <- NormalizeData(seu_sample_subset)
  sample <- FindVariableFeatures(sample)
  sample <- ScaleData(sample)
  sample <- RunPCA(sample, nfeatures.print = 10)
  
  # Find significant PCs
  stdv <- sample[["pca"]]@stdev
  percent_stdv <- (stdv/sum(stdv)) * 100
  cumulative <- cumsum(percent_stdv)
  co1 <- which(cumulative > 90 & percent_stdv < 5)[1] 
  co2 <- sort(which((percent_stdv[1:length(percent_stdv) - 1] - 
                       percent_stdv[2:length(percent_stdv)]) > 0.1), 
              decreasing = T)[1] + 1
  min_pc <- min(co1, co2)
  
  # Finish pre-processing with min_pc
  sample <- RunUMAP(sample, dims = 1:min_pc)
  sample <- FindNeighbors(object = sample, dims = 1:min_pc)              
  sample <- FindClusters(object = sample, resolution = 0.1)
  
  # pK identification (no ground-truth) 
  #introduces artificial doublets in varying props, merges with real data set and 
  # preprocesses the data + calculates the prop of artficial neighrest neighbours, 
  # provides a list of the proportion of artificial nearest neighbours for varying
  # combinations of the pN and pK
  sweep_list <- paramSweep(sample, PCs = 1:min_pc, sct = FALSE)   
  sweep_stats <- summarizeSweep(sweep_list)
  bcmvn <- find.pK(sweep_stats) # computes a metric to find the optimal pK value (max mean variance normalised by modality coefficient)
  # Optimal pK is the max of the bimodality coefficient (BCmvn) distribution
  optimal.pk <- bcmvn %>% 
    dplyr::filter(BCmetric == max(BCmetric)) %>%
    dplyr::select(pK)
  optimal.pk <- as.numeric(as.character(optimal.pk[[1]]))
  
  ## Homotypic doublet proportion estimate
  annotations <- sample@meta.data$seurat_clusters # use the clusters as the user-defined cell types
  homotypic.prop <- modelHomotypic(annotations) # get proportions of homotypic doublets
  
  nExp.poi <- round(multiplet_rate * nrow(sample@meta.data)) # multiply by number of cells to get the number of expected multiplets
  nExp.poi.adj <- round(nExp.poi * (1 - homotypic.prop)) # expected number of doublets
  
  # run DoubletFinder
  sample <- doubletFinder(seu = sample, 
                          PCs = 1:min_pc, 
                          pK = optimal.pk, # the neighborhood size used to compute the number of artificial nearest neighbours
                          nExp = nExp.poi.adj) # number of expected real doublets
  # change name of metadata column with Singlet/Doublet information
  colnames(sample@meta.data)[grepl('DF.classifications.*', colnames(sample@meta.data))] <- "doublet_finder"
  
  # Subset and save
  # head(sample@meta.data['doublet_finder'])
  # singlets <- subset(sample, doublet_finder == "Singlet") # extract only singlets
  # singlets$ident
  double_finder_res <- sample@meta.data['doublet_finder'] # get the metadata column with singlet, doublet info
  double_finder_res <- rownames_to_column(double_finder_res, "row_names") # add the cell IDs as new column to be able to merge correctly
  return(double_finder_res)
}
```

## Running the function
```{r doubletFinder-LN}
ln_split <- lapply(ln_split, run_doubletfinder_custom)
```

```{r doubletFinder-thym}
thym_split <- lapply(thym_split, run_doubletfinder_custom)
```


## Add DoubletFinder results to Seurat object
```{r}
# Lymph node
filtered_ln <- NormalizeData(filtered_ln, normalization.method = "LogNormalize", scale.factor = 10000)
filtered_ln <- FindVariableFeatures(filtered_ln)
filtered_ln <- ScaleData(filtered_ln)
filtered_ln <- RunPCA(filtered_ln)
filtered_ln <- RunUMAP(filtered_ln, dims = 1:10)

sglt_dblt_metadata_LN <- data.frame(bind_rows(ln_split)) # merge to a single dataframe
rownames(sglt_dblt_metadata_LN) <- sglt_dblt_metadata_LN$row_names # assign cell IDs to row names to ensure match
sglt_dblt_metadata_LN$row_names <- NULL
head(sglt_dblt_metadata_LN)
filtered_ln <- AddMetaData(filtered_ln, sglt_dblt_metadata_LN, col.name = "doublet_finder")
```

```{r}
# Thymus
sglt_dblt_metadata_THYM <- data.frame(bind_rows(thym_split)) # merge to a single dataframe
rownames(sglt_dblt_metadata_THYM) <- sglt_dblt_metadata_THYM$row_names # assign cell IDs to row names to ensure match
sglt_dblt_metadata_THYM$row_names <- NULL
head(sglt_dblt_metadata_THYM)
filtered_thym <- AddMetaData(filtered_thym, sglt_dblt_metadata_THYM, col.name = "doublet_finder")
```

# Summary of doublet detection results
```{r vlnplots, fig.width=8}
# Check how doublets singlets differ in QC measures per sample.
VlnPlot(filtered_ln, group.by = 'orig.ident', split.by = "doublet_finder",
        features = c("nFeature_RNA", "nCount_RNA"), 
        ncol = 3, pt.size = 0) + theme(legend.position = 'right')
```

```{r}
VlnPlot(filtered_thym,
        group.by = "orig.ident",
        split.by = "doublet_finder",
        features = c("nFeature_RNA", "nCount_RNA", "percent_mt"),
        ncol = 3,
        pt.size = 0 +
          theme(legend.position = 'right', plot.title = "Thymus")
          )
```

```{r}
DimPlot(filtered_ln,
        group.by = "doublet_finder",
        reduction = "umap",
        pt.size=0.5) + ggtitle("DoubletFinder: Canine Lymph Node")
```

```{r}
filtered_thym <- RunPCA(filtered_thym)
filtered_thym <- RunUMAP(filtered_thym, dims = 1:10)

DimPlot(filtered_thym,
        group.by = "doublet_finder",
        reduction = "umap",
        pt.size=0.5)
```


# Remove doublets and save

```{r save-singlets}
filtered_ln <- subset(filtered_ln, doublet_finder == "Singlet")
filtered_thym <- subset(filtered_thym, doublet_finder == "Singlet")

saveRDS(filtered_ln, file="merged_filtered_singlet_LN.RData")
saveRDS(filtered_ln, file="merged_filtered_singlet_THYM.RData")
```

Next step: Sample integration.

# Citations
```{r citations}
sessionInfo()
citation()
```


























